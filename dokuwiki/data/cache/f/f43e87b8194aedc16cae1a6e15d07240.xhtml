
<h1 class="sectionedit1" id="modules">Modules</h1>
<div class="level1">

<p>
Les modules sont les composants de base de la chaine et peuvent aussi être la définition d&#039;une chaine. Ces modules sont définis par des fichiers ayant la forme suivante : NOM_MODULE.module
</p>

<p>
Les noms des modules sont des chaines de caractères respectant l&#039;expression régulière suivante : <strong>nom_module</strong> (@<strong><em>namespace</em></strong>)? où <strong>nom_module</strong> et <strong>namespace</strong> sont de la forme [a-zA-Z][a-zA-Z0-9_\-]+ (ex: <em>parser@user</em>, <em>mon-module-de-normalisation@hostname</em>, <em>parser_customisé</em> @domain, …)
</p>

<p>
Des modules déjà existant se trouvent dans la distribution dans le répertoire (relatif au répertoire d&#039;installation de <strong>AppFM</strong>) modules/custom et modules/addons.
</p>

</div>
<!-- EDIT1 SECTION "Modules" [1-699] -->
<h2 class="sectionedit2" id="description_fichier_module">Description (fichier .module)</h2>
<div class="level2">

<p>
Le fichier de description d&#039;un module est en format <a href="http://learnxinyminutes.com/docs/fr-fr/yaml-fr/" class="urlextern" title="http://learnxinyminutes.com/docs/fr-fr/yaml-fr/"  rel="nofollow">YAML</a>.
</p>

<p>
Les champs obligatoires sont :
</p>

<p>
- name : Le nom du module qui DOIT correspondre au nom de base du fichier (sans l&#039;extension .module). Ce nom doit etre unique entre tous les modules enregistrés (voir configuration, modules_dir).
</p>

<p>
- input : La liste des paramètres d&#039;entrée du module (voir plus bas)
</p>

<p>
- output : La liste des paramètres de sortie du module (voir plus bas)
</p>

<p>
- exec : La liste des modules à exécuter (voir plus bas)
</p>

<p>
Il est possible et fortement recommandé de rajouter un champ “desc” qui contient une description utile du module affichée dans les différentes interfaces de <strong>AppFM</strong>.
</p>

</div>
<!-- EDIT2 SECTION "Description (fichier .module)" [700-1459] -->
<h3 class="sectionedit3" id="input">Input</h3>
<div class="level3">

<p>
Les entrées d&#039;un module sont décrites via une <em>map</em> de la forme suivante :
</p>
<pre class="code">input :
  NOM_INPUT_1 :
    type  : INPUT_TYPE
    encoding : ENCODING (optionnel, défaut étant utf-8) # not implemented
    format : FORMAT (optionnel)
    schema : SCHEMA (optionnel)
    desc : description optionnelle
    value : valeur par défault optionnelle
  NOM_INPUT_2 :
    ...
  ...
  NOM_INPUT_N  :
...</pre>

<p>
Chaque <strong>input</strong><strong>/parametre </strong>à un <strong>nom unique</strong> dans le module et est donné en tant que clé pour sa description interne. Ce nom définit une <strong>variable</strong> (voir plus bas) réutilisable dans la description du module.
</p>

<p>
Ce nom DOIT respecter l&#039;expression régulière suivante : [A-Z][A-Z0-9_]*
</p>

<p>
Le seul parametre vraiment requis est le <strong>type </strong> du paramètre. Il en existe 3 (pour l&#039;instant) qui seront décrit plus bas : <strong>VAL</strong>, <strong>FILE</strong>, <strong>DIR</strong>
</p>

<p>
Le type peut etre complémenté des quantificateurs suivants : * pour un nombre indéfini de valeurs, <strong>+</strong> pour un nombre strictement positif de valeurs et <strong>?</strong> pour une ou aucune valeur (paramètre optionnel)
</p>

</div>
<!-- EDIT3 SECTION "Input" [1460-2553] -->
<h3 class="sectionedit4" id="output">Output</h3>
<div class="level3">

<p>
Symmétriquement aux entrées d&#039;un module, les sorties sont décrites via une <em>map</em> de la forme suivante :
</p>
<pre class="code">output :
  NOM_OUTPUT_1 :
    type  : OUTPUT_TYPE
    encoding : ENCODING (optionnel, défaut est utf-8) # not implemented
    format : FORMAT (optionnel)
    schema : SCHEMA (optionnel)
    desc : description optionnelle
    value : valeur de sortie
  NOM_OUTPUT_2 :
    ...
  ...
  NOM_OUTPUT_N  :
...</pre>

<p>
Tout comme les entrées, chaque <strong>input</strong><strong>/parametre </strong>à un nom unique et le champ <strong>type</strong> a la même sémantique.
</p>

<p>
La différence se trouve dans l&#039;obligation de renseigner le champ <strong>val</strong><strong>ue</strong>.
</p>

</div>
<!-- EDIT4 SECTION "Output" [2554-3200] -->
<h3 class="sectionedit5" id="exec">Exec</h3>
<div class="level3">

<p>
Le champ <strong>exec</strong> est un champ composé d&#039;une liste d&#039;<strong>instances</strong><strong> de</strong><strong> modules</strong> (<strong>moduleval</strong>) qui prend la forme suivante :
</p>
<pre class="code">exec :
  - &quot;nom-de-module-1#namespace-optionel-1&quot; :
      input :
        INPUT-1 : VALEUR
        ...
      output :
        OUTPUT-1 : ALIAS
        ...
  - ...</pre>

<p>
Chaque <strong>instance de module</strong> est décrite par le <strong>nom du module</strong> postfixé optionnellement par un <strong>nom d&#039;espace/namespace </strong> précédé de “<strong>#</strong>”, si le module est réutilisé dans la définition d&#039;exécution afin d&#039;éviter les conflits dans les chemins d&#039;accès au variables.
</p>

<p>
Toutes ses entrées requises doivent être renseignée par des valeurs fixes ou composées de <strong>variables</strong>.
</p>

</div>
<!-- EDIT5 SECTION "Exec" [3201-3920] -->
<h3 class="sectionedit6" id="variables">Variables</h3>
<div class="level3">

<p>
Les variables sont des alias correspondant à des valeurs définies à l&#039;extérieur ou à l&#039;intérieur du module. Il en existe plusieurs types, celles définies par le <strong>nom des paramètres d&#039;entrée</strong>, les valeurs de <strong>sorties des modules exécutés</strong>, et quelques <strong>globales</strong> qui sont les suivantes :
</p>

<p>
- <strong>_DEF_DIR </strong>: le répertoire où se situe la définition du module
</p>

<p>
- <strong>_RUN_DIR</strong> : le répertoire dans lequel s&#039;éxecute le module
</p>

<p>
- <strong>_RUN_ID </strong>: l&#039;id du run courant
</p>

<p>
Les variables de <strong>sorties des modules éxécutés </strong> (qui se trouvent dans le champ <strong>run</strong>) sont accessible soit par leur “chemin d&#039;accès”, ie (<em>NOM_MODULE.NOM_OUTPUT</em>), ou par un alias/nom de variable assigné dans la descritption du <strong>run</strong>.
</p>

<p>
Les variables sont utilisées en préfixant le nom de la variable par le caractère <strong>$</strong>. Pour les variables “internes” (NOM_VARIABLE<strong>:</strong> VARIABLE), il faut encapsuler le chemin dans le patron <strong>${</strong><em>CHEMIN_ACCESS</em><strong>}</strong>.
</p>

</div>
<!-- EDIT6 SECTION "Variables" [3921-4895] -->
<h2 class="sectionedit7" id="types_de_variables_parametres">Types de variables/paramètres</h2>
<div class="level2">

<p>
Chaque type de variable à une représentation par défaut sous forme de chaine de caractère. Certaines variables
</p>

</div>
<!-- EDIT7 SECTION "Types de variables/paramètres" [4896-5055] -->
<h3 class="sectionedit8" id="val_stream">VAL/STREAM</h3>
<div class="level3">

<p>
Les entrées de types <strong>VAL</strong> sont des chaines de caractères.
</p>

<p>
Par défaut, l&#039;encoding est <strong>utf-8</strong>
</p>

<p>
Représentation chaine de caractères : identité
</p>

</div>
<!-- EDIT8 SECTION "VAL/STREAM" [5056-5231] -->
<h3 class="sectionedit9" id="file">FILE</h3>
<div class="level3">

<p>
Défaut conversions : fromDir
</p>

<p>
Représentation chaine de caractère : chemin du fichier
</p>

<p>
variables internes :
</p>
<div class="table sectionedit10"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"><strong>basedir</strong>   </td><td class="col1">parent directory path </td><td class="col2">VAL </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"><strong>basenam</strong><strong>e</strong>   </td><td class="col1">name of the file without last extension (.???) </td><td class="col2">VAL </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"><strong>filename</strong>   </td><td class="col1">filename </td><td class="col2">VAL </td>
	</tr>
</table></div>
<!-- EDIT10 TABLE [5359-5511] -->
</div>
<!-- EDIT9 SECTION "FILE" [5232-5512] -->
<h3 class="sectionedit11" id="dir">DIR</h3>
<div class="level3">

<p>
Représentation chaine de caractère : chemin du dossier
</p>

<p>
variables internes :
</p>
<div class="table sectionedit12"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"><strong>ls</strong>   </td><td class="col1">list des fichiers directement enfants </td><td class="col2">FILE* </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"><strong>rls</strong>   </td><td class="col1">liste récursive de tous les fichiers </td><td class="col2">FILE* </td>
	</tr>
</table></div>
<!-- EDIT12 TABLE [5608-5724] -->
</div>
<!-- EDIT11 SECTION "DIR" [5513-5725] -->
<h3 class="sectionedit13" id="module">MODULE</h3>
<div class="level3">

<p>
Représentation chaine de caractère : yaml représentation d&#039;un ModuleVal
</p>

</div>
<!-- EDIT13 SECTION "MODULE" [5726-5819] -->
<h3 class="sectionedit14" id="list_type_type">LIST[type] | type(+|*)</h3>
<div class="level3">

<p>
Représentation chaine de caractère : représentation en chaine de caractères des éléments séparés par des espaces OU représentation en liste yaml des représentations en chaine de caractère des éléments
</p>

</div>
<!-- EDIT14 SECTION "LIST[type] | type(+|*)" [5820-6068] -->
<h3 class="sectionedit15" id="map">MAP</h3>
<div class="level3">

<p>
Représentation en chaine de caractère : yaml map des représentation en chaine de caractères des éléments
</p>

</div>
<!-- EDIT15 SECTION "MAP" [6069-6195] -->
<h2 class="sectionedit16" id="modules_natifs_built-in_modules">Modules natifs / Built-in modules</h2>
<div class="level2">

<p>
Ces modules sont des modules dont l&#039;exécution (champ <em>run</em>) est intégrée directement dans le fonctionnement de <strong>cpm</strong>. Ils sont les briques de bases qui permettent de constituer des modules.
</p>

</div>
<!-- EDIT16 SECTION "Modules natifs / Built-in modules" [6196-6439] -->
<h3 class="sectionedit17" id="cmd">_CMD</h3>
<div class="level3">

<p>
Ce module permet tout simplement de lancer une commande, possiblement à l&#039;intérieur d&#039;un conteneur Docker.
</p>
<div class="table sectionedit18"><table class="inline">
	<tr class="row0">
		<td class="col0" colspan="3"><strong>Input</strong> </td><td class="col3 leftalign">  </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>CMD</strong>   </td><td class="col2">VAL </td><td class="col3">commande à executer </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>DOCKERFILE</strong>   </td><td class="col2">VAL (true </td><td class="col3">false) </td><td class="col4">indique si la commande doit s&#039;éxécuter à l&#039;intérieur d&#039;un conteneur Docker définit par une Dockerfile </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>CONTAINED</strong>   </td><td class="col2">VAL (true </td><td class="col3">false) </td><td class="col4">indique si pour chaque execution un nouveau conteneur Docker est créé ou si une seule instance suffit </td>
	</tr>
	<tr class="row4">
		<td class="col0" colspan="3"><strong>Output</strong> </td><td class="col3 leftalign">  </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>STDOUT</strong>   </td><td class="col2">VAL </td><td class="col3">sortie standard de la commande </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>STDERR</strong>   </td><td class="col2">VAL </td><td class="col3">sortie d&#039;erreur de la commande </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row7">
		<td class="col0" colspan="3"><strong>Exec</strong> </td><td class="col3 leftalign">  </td><td class="col4 leftalign">  </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign">  </td><td class="col1" colspan="2">execute a shell command (with <strong>_RUN_WD</strong> </td><td class="col3">as working directory) </td><td class="col4 leftalign">  </td>
	</tr>
</table></div>
<!-- EDIT18 TABLE [6566-7163] -->
<p>
TODO : explication docker
</p>

</div>
<!-- EDIT17 SECTION "_CMD" [6440-7191] -->
<h3 class="sectionedit19" id="map1">_MAP</h3>
<div class="level3">

<p>
Ce module permet de distribuer parallèlement les fichiers d&#039;un corpus ou d&#039;un répertoire à un ensemble de processus ayant au moins une entrée de type FILE.
</p>
<div class="table sectionedit20"><table class="inline">
	<tr class="row0">
		<td class="col0" colspan="4"><strong>Input</strong> </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>IN</strong>   </td><td class="col2">DIR </td><td class="col3 leftalign">le répertoire dont chaque fichier va être la source d&#039;une execution en parallèle des modules définis dans la variable <strong>RUN</strong> avec pour nom <strong>$_</strong>   </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>RUN</strong>   </td><td class="col2">MODULE+ </td><td class="col3">liste d&#039;instance de modules </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>REGEX</strong>   </td><td class="col2">VAL </td><td class="col3">expression régulière filtrant les fichiers du répertoire qui seront traités </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>CHUNK_SIZE</strong>   </td><td class="col2">VAL </td><td class="col3">nombre de processus exécutés en parallèle (defaut 20) </td>
	</tr>
	<tr class="row5">
		<td class="col0" colspan="4"><strong>Output</strong> </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign">  </td><td class="col1 leftalign"><strong>OUT</strong>   </td><td class="col2" colspan="2">MAP </td>
	</tr>
	<tr class="row7">
		<td class="col0" colspan="4"><strong>Exec</strong> </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign">  </td><td class="col1" colspan="3">execute in parallel the moduleval list on a files in the entry. produce a map of keyed modulenamespace outputs </td>
	</tr>
</table></div>
<!-- EDIT20 TABLE [7369-7975] -->
</div>
<!-- EDIT19 SECTION "_MAP" [7192-7976] -->
<h2 class="sectionedit21" id="formats_schemas">Formats / Schemas</h2>
<div class="level2">

</div>
<!-- EDIT21 SECTION "Formats / Schemas" [7977-8007] -->
<h3 class="sectionedit22" id="formats">Formats</h3>
<div class="level3">

<p>
Le format est la syntaxe d&#039;une donnée. Pour le texte il s&#039;agit principalement de : tabular/CSV, xml, json, yaml ou autre personnelle
</p>

<p>
Il doit etre possible de convertir automatiquement certains formats en d&#039;autres (par exemple yaml&lt;→json&lt;→xml).
</p>

</div>
<!-- EDIT22 SECTION "Formats" [8008-8277] -->
<h3 class="sectionedit23" id="schema">Schema</h3>
<div class="level3">

<p>
Le schema définit la sémantique d&#039;une donnée. Par exemple : passage, depxml, ConLL, stanford, etc.
</p>

<p>
Les schemas sont combinables, certains sont implicitement mutuellement exclusifs. On ne verifiera pas la mutuel exclusion.
</p>

<p>
Ainsi nous avons défini les formats suivants : Annotation qui est définit par un contenu (texte d&#039;un xml) dont des spans sont annotés, et CAS qui en xml a des champs specifiques pour déclarer des annotations globales au document et des annotations sur des parties d&#039;un texte original.
</p>

</div>
<!-- EDIT23 SECTION "Schema" [8278-8812] -->
<h3 class="sectionedit24" id="encoding">Encoding</h3>
<div class="level3">

<p>
L&#039;encoding est l&#039;information qui permet de décoder le signal de base (bits) en des structures informatique natives (char,int,etc.) bas niveau.
</p>

<p>
La variable <strong>ENC_DFT</strong> (qui peut etre overridé dans la configuration de run) définit la valeur par défaut qui est pour le texte : l&#039;utf-8
</p>

</div>
<div class="level3">

</div>
<!-- EDIT24 SECTION "Encoding" [8813-9132] -->
<h2 class="sectionedit25" id="gestion_des_dependances">Gestion des dépendances</h2>
<div class="level2">

<p>
- all in a folder static linking (big module in memory size.., possible redundance with other modules…)
</p>

<p>
- compose your own docker (using the base one with cpm-process-shell as entrypoint)
</p>

</div>
<!-- EDIT25 SECTION "Gestion des dépendances" [9133-9362] -->
<h2 class="sectionedit26" id="modules_supplementaires_addons_modules">Modules supplémentaires / Addons modules</h2>
<div class="level2">

<p>
toUTF8
</p>

<p>
toLatin1
</p>

<p>
jsonToXML
</p>

<p>
XMLtoJSON
</p>

<p>
xml_merger
</p>

</div>
<!-- EDIT26 SECTION "Modules supplémentaires / Addons modules" [9363-9469] -->
<h2 class="sectionedit27" id="examples">Examples</h2>
<div class="level2">

<p>
à venir :
</p>

<p>
- stanford-parser + wolf + unitex in parallel, merging job with xml_merger (basic use _map, _cmd, _filter, etc.)
</p>

<p>
- chaine pulsar
</p>

<p>
<br/>

</p>

</div>
<!-- EDIT27 SECTION "Examples" [9470-] -->