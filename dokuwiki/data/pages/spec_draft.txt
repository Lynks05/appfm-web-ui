====== Modules ======

Les modules sont les composants de base de la chaine et peuvent aussi être la définition d'une chaine. Ces modules sont définis par des fichiers ayant la forme suivante : NOM_MODULE.module

Les noms des modules sont des chaines de caractères respectant l'expression régulière suivante : **nom_module** (@**//namespace//**)? où **nom_module** et **namespace** sont de la forme [a-zA-Z][a-zA-Z0-9_\-]+ (ex: //parser@user//, //mon-module-de-normalisation@hostname//, //parser_customisé// @domain, …)

Des modules déjà existant se trouvent dans la distribution dans le répertoire (relatif au répertoire d'installation de **cpm**) modules/default et modules/addons.
===== Description (fichier .module) =====

Le fichier de description d'un module est en format [[http://learnxinyminutes.com/docs/fr-fr/yaml-fr/|YAML]].

Les champs obligatoires sont :

- name : Le nom du module qui DOIT correspondre au nom de base du fichier (sans l'extension .module). Ce nom doit etre unique entre tous les modules enregistrés (voir configuration, modules_dir).

- input : La liste des paramètres d'entrée du module (voir plus bas)

- output : La liste des paramètres de sortie du module (voir plus bas)

- log : La liste des sorties de log du module

- exec : La liste des modules à exécuter (voir plus bas)

Il est possible de rajouter un champ "desc" qui contient une description utile du module affichée dans les différentes interfaces de **cpm**.
==== Input ====

Les entrées d'un module sont décrites via une //map// de la forme suivante :
<code>
input :
  NOM_INPUT_1 :
    type  : INPUT_TYPE
    encoding : ENCODING (optionel, défaut étant utf-8)
    format : FORMAT (optionel)
    schema : SCHEMA (optionel)
    desc : description optionnelle
    value : valeur par défault optionnelle
  NOM_INPUT_2 :
    ...
  ...
  NOM_INPUT_N  :
...
</code>

Chaque **input****/parametre **à un **nom unique** dans le module et est donné en tant que clé pour sa description interne. Ce nom définit une **variable** (voir plus bas) réutilisable dans la description du module.

Ce nom DOIT respecter l'expression régulière suivante : [A-Z][A-Z0-9_]*

Le seul parametre vraiment requis est le **type ** du paramètre. Il en existe 4 qui seront décrit plus bas : **VAL**, **FILE**, **DIR**, **CORPUS**

Le type peut etre complémenté des quantificateurs suivants : * pour un nombre indéfini de valeurs, **+** pour un nombre strictement positif de valeurs et **?** pour une ou aucune valeur (paramètre optionnel)
==== Output ====

Symmétriquement aux entrées d'un module, les sorties sont décrites via une //map// de la forme suivante :
<code>
output :
  NOM_OUTPUT_1 :
    type  : OUTPUT_TYPE
    encoding : ENCODING (optionel, défaut est utf-8)
    format : FORMAT (optionel)
    schema : SCHEMA (optionel)
    desc : description optionnelle
    value : valeur de sortie
  NOM_OUTPUT_2 :
    ...
  ...
  NOM_OUTPUT_N  :
...
</code>

Tout comme les entrées, chaque **input****/parametre **à un nom unique et le champ **type** a la même sémantique.

La différence se trouve dans l'obligation de renseigner le champ **val****ue**.
==== Exec ====

Le champ **run** est un champ composé d'une liste d'**instances**** de**** modules** (**moduleval**) qui prend la forme suivante :
<code>
exec :
  - nom-de-module-1.namespace-optionel-1 :
      input :
        INPUT-1 : VALEUR
        ...
      output :
        OUTPUT-1 : ALIAS
        ...
  - ...
</code>

Chaque **instance de module** est décrite par le **nom du module** postfixé optionnellement par un **nom d'espace/namespace ** précédé d'un point "**.**", si le module est réutilisé dans la définition d'exécution afin d'éviter les conflits dans les chemins d'accès au variables.

Toutes ses entrées requises doivent être renseignée par des valeurs fixes ou composées de **variables**.
==== Variables ====

Les variables sont des alias correspondant à des valeurs définies à l'extérieur ou à l'intérieur du module. Il en existe plusieurs types, celles définies par le **nom des paramètres d'entrée**, les valeurs de **sorties des modules exécutés**, et quelques **globales** qui sont les suivantes :

- **_DEF_DIR **: le répertoire où se situe la définition du module

- **_RUN_DIR** : le répertoire dans lequel s'éxecute le module

- **ENC_DFT** : l'encodage par défaut des inputs

- **_RUN_ID **: l'id du run courant

Les variables de **sorties des modules éxécutés ** (qui se trouvent dans le champ **run**) sont accessible soit par leur "chemin d'accès", ie (//NOM_MODULE.NOM_OUTPUT//), ou par un alias/nom de variable assigné dans la descritption du **run**.

Les variables sont utilisées en préfixant le nom de la variable par le caractère **$**. Pour les variables "internes", il faut encapsuler le chemin dans le patron **${**//CHEMIN_ACCESS//**}**.
===   ===

==== Log ====

La définition des logs se fait sous la forme suivante :

<code>
log :
  NOM_DU_LOG_0 : chemin d'accès du log
  ...
</code>

===== Types de variables/paramètres =====

Chaque type de variable à une représentation par défaut sous forme de chaine de caractère. Certaines variables

==== VAL/STREAM ====

Les entrées de types **VAL** sont des chaines de caractères.

Par défaut, l'encoding est **utf-8**

Représentation chaine de caractères : identité

==== FILE ====

Défaut conversions : fromDir

Représentation chaine de caractère : chemin du fichier

variables internes :

|**basedir**   |parent directory path |VAL |
|**basenam****e**   |name of the file without last extension (.???) |VAL |
|**filename**   |filename |VAL |

==== DIR ====

Représentation chaine de caractère : chemin du dossier

variables internes :

|**ls**   |list des fichiers directement enfants |FILE* |
|**rls**   |liste récursive de tous les fichiers |FILE* |

==== CORPUS ====

Représentation chaine de caractère : id du corpus

variables internes :

|**ls**   |liste de tous les fichiers du corpus |FILE* |
|**dir**   |répertoire racine du corpus |DIR |
|**name**   |nom du corpus |VAL |

==== MODULE ====

Représentation chaine de caractère : yaml représentation d'un ModuleVal

==== LIST[type] | type(+|*) ====

Représentation chaine de caractère : représentation en chaine de caractères des éléments séparés par des espaces OU représentation en liste yaml des représentations en chaine de caractère des éléments

==== MAP ====

Représentation en chaine de caractère : yaml map des représentation en chaine de caractères des éléments

===== Modules natifs / Built-in modules =====

Ces modules sont des modules dont l'exécution (champ //run//) est intégrée directement dans le fonctionnement de **cpm**. Ils sont les briques de bases qui permettent de constituer des modules.
==== _CMD ====

Ce module permet tout simplement de lancer une commande.

|**Input** |||  |
|  |**CMD**   |VAL |  |
|**Output** |||  |
|  |**STDOUT**   |VAL |  |
|**Log** |||  |
|  |**STDERR**   |VAL |  |
|**Exec** |||  |
|  |execute a shell command (with **_RUN_WD** ||as working directory) |

==== _MAP ====

Ce module permet de distribuer parallèlement les fichiers d'un corpus ou d'un répertoire à un ensemble de processus ayant au moins une entrée de type FILE.

|**Input** |||
|  |**IN**   |FILE+ |
|  |**RUN**   |MODULE+ |
|**Output** |||
|  |**OUT**   |MAP |
|**Log** |||
|  |**ERR**   |MAP |
|**Exec** |||
|  |execute in parallel the moduleval list on a files in the entry. produce a map of keyed modulenamespace outputs ||

==== _LOOP ====

Ce module permet de distribuer séquentiellement les fichiers d'un corpus ou d'un répertoire à un ensemble de processus ayant au moins une entrée de type FILE.

|**Input** |||
|  |**CMD**   |VAL |
|**Output** |||
|  |**STDOUT**   |VAL |
|**Log** |||
|  |**STDERR**   |VAL |
|**Exec** |||
|  |  ||

==== _FILTER ====

Ce module permet de filter un ensemble de fichiers en un sous ensemble dépendant d'une regex

|**Input** |||  |
|  |**CMD**   |VAL |  |
|**Output** |||  |
|  |**STDOUT**   |VAL |  |
|**Log** |||  |
|  |**STDERR**   |VAL |  |
|**Exec** |||  |
|  |execute a shell command (with **_RUN_WD** ||as working directory) |

==== _SPLITTER ====

Ce module permet de filter le contenu d'un fichier via une regex et de créer une liste de fichier contenant les éléments filtrés

|**Input** |||  |
|  |**CMD**   |VAL |  |
|**Output** |||  |
|  |**STDOUT**   |VAL |  |
|**Log** |||  |
|  |**STDERR**   |VAL |  |
|**Exec** |||  |
|  |execute a shell command (with **_RUN_WD** ||as working directory) |

===== Formats / Schemas =====

==== Formats ====

Le format est la syntaxe d'une donnée. Pour le texte il s'agit principalement de : tabular/CSV, xml, json, yaml ou autre personnelle

Il doit etre possible de convertir automatiquement certains formats en d'autres (par exemple yaml<→json<→xml).

==== Schema ====

Le schema définit la sémantique d'une donnée. Par exemple : passage, depxml, ConLL, stanford, etc.

Les schemas sont combinables, certains sont implicitement mutuellement exclusifs. On ne verifiera pas la mutuel exclusion.

Ainsi nous avons défini les formats suivants : Annotation qui est définit par un contenu (texte d'un xml) dont des spans sont annotés, et CAS qui en xml a des champs specifiques pour déclarer des annotations globales au document et des annotations sur des parties d'un texte original.

==== Encoding ====

L'encoding est l'information qui permet de décoder le signal de base (bits) en des structures informatique natives (char,int,etc.) bas niveau.

La variable **ENC_DFT** (qui peut etre overridé dans la configuration de run) définit la valeur par défaut qui est pour le texte : l'utf-8
====   ====

===== Gestion des dépendances =====

- all in a folder static linking (big module in memory size.., possible redundance with other modules...)

- compose your own docker (using the base one with cpm-process-shell as entrypoint)

===== Modules supplémentaires / Addons modules =====

toUTF8

toLatin1

jsonToXML

XMLtoJSON

xml_merger

===== Examples =====

à venir :

- stanford-parser + wolf + unitex in parallel, merging job with xml_merger (basic use _map, _cmd, _filter, etc.)

- chaine pulsar

\\
