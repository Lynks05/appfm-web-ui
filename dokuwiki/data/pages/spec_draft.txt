====== Modules ======

Les modules sont les descriptions du cadre et de l'exécution d'une application ou d'une chaine d'applications. Ces modules sont définis par des fichiers ayant la forme suivante : NOM_MODULE.module

Les noms des modules sont des chaines de caractères respectant l'expression régulière suivante : **nom_module** (@**//namespace//**)? où **nom_module** et **namespace** sont de la forme [a-zA-Z][a-zA-Z0-9_\-]+ (ex: //parser@user//, //mon-module-de-normalisation@hostname//, //parser_customisé// @domain, …)

Ces fichiers de définition ainsi que les autres fichiers nécessaires à l'exécution des modules se trouvent dans les répertoires définis dans la **[[:configuration|configuration d'AppFM​]]** (variable ''modules_dir'').
===== Description (fichier .module) =====

Le fichier de description d'un module est en format [[http://learnxinyminutes.com/docs/fr-fr/yaml-fr/|YAML]].

Les champs obligatoires sont :

- name : Le nom du module qui DOIT correspondre au nom de base du fichier (sans l'extension .module). Ce nom doit etre unique entre tous les modules enregistrés (voir configuration, modules_dir).

- input : La liste des paramètres d'entrée du module (voir plus bas)

- output : La liste des paramètres de sortie du module (voir plus bas)

- exec : La liste des modules à exécuter (voir plus bas)

Il est possible et fortement recommandé de rajouter un champ "desc" qui contient une description utile du module affichée dans les différentes interfaces de **AppFM**.
==== Input ====

Les entrées d'un module sont décrites via une //map// de la forme suivante :
<code>
input :
  NOM_INPUT_1 :
    type  : INPUT_TYPE
    format : FORMAT (optionnel)
    schema : SCHEMA (optionnel)
    desc : description optionnelle
    value : valeur par défault optionnelle
  NOM_INPUT_2 :
    ...
  ...
  NOM_INPUT_N  :
...
</code>

Chaque **input****/parametre **à un **nom unique** dans le module et est donné en tant que clé pour sa description interne. Ce nom définit une **variable** (voir plus bas) réutilisable dans la description du module.

Ce nom DOIT respecter l'expression régulière suivante : [A-Z][A-Z0-9_]*

Le seul parametre obligatoire est le **type ** du paramètre. Il en existe 3 qui seront décrit plus bas : **VAL**, **FILE**, **DIR**

Le champ **format** et **schema** permet de spécifier la sémantique du paramètre.

Le champ **desc** permet d'ajouter une description supplémentaire au paramètre.

Le champ **value** permet de donner une valeur par défaut au paramètre.

Le type peut etre complémenté des quantificateurs suivants : ***** pour un nombre indéfini de valeurs et **+** pour un nombre strictement positif de valeurs. Les paramètres optionnelles sont ceux ayant une valeur par défaut donnée.
==== Output ====

Symmétriquement aux entrées d'un module, les sorties sont décrites via une //map// de la forme suivante :
<code>
output :
  NOM_OUTPUT_1 :
    type  : OUTPUT_TYPE
    format : FORMAT (optionnel)
    schema : SCHEMA (optionnel)
    desc : description optionnelle
    value : valeur de sortie
  NOM_OUTPUT_2 :
    ...
  ...
  NOM_OUTPUT_N  :
...
</code>

Tout comme les entrées, chaque **input****/parametre **à un nom unique et le champ **type** a la même sémantique.

La différence se trouve dans l'obligation de renseigner le champ **val****ue**.
==== Exec ====

Le champ **exec** est un champ composé d'une liste d'**instances**** de**** modules** (**moduleval**) qui prend la forme suivante :
<code>
exec :
  - "nom-de-module-1#namespace-optionel-1" :
      INPUT-1 : VALEUR
        ...
  - ...
</code>

Chaque **instance de module** est décrite par le **nom du module** postfixé optionnellement par un **nom d'espace/namespace ** précédé de "**#**", si le module est réutilisé dans la définition d'exécution afin d'éviter les conflits dans les chemins d'accès au variables.

Toutes ses entrées requises doivent être renseignée par des valeurs fixes ou composées de **variables**.
==== Variables ====

Les variables sont des alias correspondant à des valeurs définies à l'extérieur ou à l'intérieur du module. Il en existe plusieurs types, celles définies par le **nom des paramètres d'entrée**, les valeurs de **sorties des modules exécutés**, et quelques **globales** qui sont les suivantes :

- **_DEF_DIR **: le répertoire où se situe la définition du module

- **_RUN_DIR** : le répertoire dans lequel s'éxecute le module

Les variables de **sorties des modules éxécutés ** (qui se trouvent dans le champ **exec**) sont accessible soit par leur "chemin d'accès", ie (//NOM_MODULE.NOM_OUTPUT//).

Les variables sont utilisées en préfixant le nom de la variable par le caractère **$**. Pour les variables "internes" (NOM_VARIABLE**:** VARIABLE), il faut encapsuler le chemin dans le patron **${**//CHEMIN_ACCESS//**}**.
===== Types de variables/paramètres =====

Chaque type de variable à une représentation par défaut sous forme de chaine de caractère qui est utilisée lors de son remplacement dans l'éxécution définie dans le champs **exec**.
==== VAL ====

Les entrées de types **VAL** sont des chaines de caractères.

Par défaut, l'encodage est **utf-8**

Représentation chaine de caractères : identité

==== FILE ====

Représentation chaine de caractère : chemin du fichier

variables internes :

|**basedir**   |chemin du répertoire parent |VAL |
|**basenam****e**   |nom du fichier sans sa dernière extension (.???) |VAL |
|**filename**   |nom du fichier (sans le chemin complet) |VAL |
|**content**   |contenu du fichier |VAL |

==== DIR ====

Représentation chaine de caractère : chemin du dossier

variables internes :

|**ls**   |list des fichiers directement enfants |FILE* |
|**rls**   |liste récursive de tous les fichiers |FILE* |

==== MODULE ====

Représentation chaine de caractère : représentation yaml d'un ModuleVal

==== LIST[type] | type(+|*) ====

Représentation chaine de caractère : représentation en chaine de caractères des éléments séparés par des espaces OU représentation en liste yaml des représentations en chaine de caractère des éléments

==== MAP ====

Représentation en chaine de caractère : yaml map des représentation en chaine de caractères des éléments

===== Modules natifs / Built-in modules =====

Ces modules sont des modules dont l'exécution (champ //run//) est intégrée directement dans le fonctionnement de **appfm**. Ils sont les briques de bases qui permettent de constituer des modules.
==== _CMD ====

Ce module permet tout simplement de lancer une commande, possiblement à l'intérieur d'un conteneur Docker.

|**Input** |||  |  |  |
|  |**CMD**   |VAL |commande shell à executer |  |  |
|  |**DOCKERFILE**   |VAL |Le nom ou chemin relatif du Dockerfile utilisé (ou false si pas de docker utilisé) |indique si la commande doit s'éxécuter à l'intérieur d'un conteneur Docker définit par une Dockerfile |  |
|  |**CONTAINED**   |VAL (true,false) |  |indique si pour chaque execution un nouveau conteneur Docker est créé ou si une seule instance suffit |  |
|  |**DOCKEROPTS**   |VAL |options à passer au lancement du conteneur Docker |  |  |
|**Output** |||  |  |  |
|  |**STDOUT**   |VAL |sortie standard de la commande |  |  |
|  |**STDERR**   |VAL |sortie d'erreur de la commande |  |  |
|**Exec** |||  |  |  |
|  |execute a shell command (with **_RUN_** ||**DIR ** as working directory)  |  |  |

Pour plus d'explication sur docker et comment créer un Dockerfile adapté à AppFM, continuer la lecture [[:docker|ici]].

==== _MAP ====

Ce module permet de distribuer parallèlement les fichiers d'un corpus ou d'un répertoire à un ensemble de processus ayant au moins une entrée de type FILE.

|**Input** ||||
|  |**IN**   |DIR |le répertoire dont chaque fichier va être la source d'une execution en parallèle des modules définis dans la variable **RUN** avec pour nom **$_**   |
|  |**RUN**   |MODULE+ |liste d'instance de modules |
|  |**REGEX**   |VAL |expression régulière filtrant les fichiers du répertoire qui seront traités |
|**Output** ||||
|  |**OUT**   |DIR |le répertoire parent des répertoires contenant les résultats des modules exécutés (définis dans le champ RUN) |
|**Exec** ||||
|  |exécute en parallèle les modules sur chaques fichiers contenus (et filtrés par l'expression régulière) dans le répertoire d'entrée.  |||

===== Formats / Schemas =====

==== Formats ====

Le format est la syntaxe d'une donnée. Pour le texte il s'agit principalement de : tabular/CSV, xml, json, yaml ou autre personnelle

Il doit etre possible de convertir automatiquement certains formats en d'autres (par exemple yaml<→json<→xml).

==== Schema ====

Le schema définit la sémantique d'une donnée. Par exemple : passage, depxml, ConLL, stanford, etc.

Cette typologie est définie par le créateur des modules et n'est actuellement pas prise en compte dans le lancement d'une chaine.

====   ====

===== Gestion des dépendances =====

- all in a folder static linking (big module in memory size.., possible redundance with other modules…)

- compose your own docker (using the base one with cpm-process-shell as entrypoint)

===== Modules supplémentaires / Addons modules =====

toUTF8

toLatin1

jsonToXML

XMLtoJSON

xml_merger

===== Examples =====

à venir :

- stanford-parser + wolf + unitex in parallel, merging job with xml_merger (basic use _map, _cmd, _filter, etc.)

- chaine pulsar

\\
